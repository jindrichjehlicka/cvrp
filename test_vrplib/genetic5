import random
import numpy as np
import vrplib

instance = vrplib.read_instance("./Vrp-Set-XML100/instances/XML100_1111_03.vrp")

# Assuming you have already loaded these from your instance
depot_loc = instance['node_coord'][0]
node_loc = instance['node_coord']
demand = instance['demand']
capacity = instance['capacity']


# Helper function to calculate distance
def distance(a, b):
    return np.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2)


# Calculate distances matrix
n_nodes = len(node_loc)
distance_matrix = np.zeros((n_nodes, n_nodes))
for i in range(n_nodes):
    for j in range(n_nodes):
        distance_matrix[i][j] = distance(node_loc[i], node_loc[j])


def generate_solution():
    nodes = list(range(1, n_nodes))  # start from 1 to skip depot
    random.shuffle(nodes)
    solution = []
    current_capacity = capacity
    route = [0]  # start from depot

    for node in nodes:
        if demand[node] <= current_capacity:
            route.append(node)
            current_capacity -= demand[node]
        else:
            route.append(0)  # return to depot
            solution.append(route)
            route = [0, node]
            current_capacity = capacity - demand[node]
    route.append(0)  # end last route at depot
    solution.append(route)
    return solution


def initial_population(size):
    return [generate_solution() for _ in range(size)]


def calculate_cost(solution):
    total_distance = 0
    for route in solution:
        for i in range(len(route) - 1):
            total_distance += distance_matrix[route[i]][route[i + 1]]
    return total_distance


def fitness(solution):
    return 1 / calculate_cost(solution)  # Higher fitness is better


def select(population, fitnesses, k=3):
    selected = sorted(zip(population, fitnesses), key=lambda x: x[1], reverse=True)
    return [x for x, _ in selected[:k]]


def crossover(parent1, parent2):
    # Simple one-point crossover
    point = random.randint(1, len(parent1) - 2)
    return parent1[:point] + parent2[point:]


def mutate(solution, mutation_rate=0.01):
    for i in range(len(solution)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(solution) - 1)
            solution[i], solution[j] = solution[j], solution[i]
    return solution


# def genetic_algorithm(population_size, generations):
#     pop = initial_population(population_size)
#     for generation in range(generations):
#         fitnesses = [fitness(sol) for sol in pop]
#         selected = select(pop, fitnesses, k=int(population_size / 2))
#         next_gen = []
#         while len(next_gen) < population_size:
#             p1, p2 = random.sample(selected, 2)
#             offspring = crossover(p1, p2)
#             offspring = mutate(offspring)
#             next_gen.append(offspring)
#         pop = next_gen
#         print(f"Generation {generation}, Best fitness: {max(fitnesses)}")
#     return pop

def genetic_algorithm(population_size, generations):
    pop = initial_population(population_size)
    best_solution = None
    best_cost = float('inf')  # Initialize with a large number

    for generation in range(generations):
        fitnesses = [fitness(sol) for sol in pop]
        current_best_index = np.argmax(fitnesses)
        current_best_solution = pop[current_best_index]
        current_best_solution_cost = calculate_cost(current_best_solution)

        # Update the best solution if the current one is better
        if current_best_solution_cost < best_cost:
            best_cost = current_best_solution_cost
            best_solution = current_best_solution

        selected = select(pop, fitnesses, k=int(population_size / 2))
        next_gen = []
        while len(next_gen) < population_size:
            p1, p2 = random.sample(selected, 2)
            offspring = crossover(p1, p2)
            offspring = mutate(offspring)
            next_gen.append(offspring)
        pop = next_gen

        # Optionally print the generation info
        # print(f"Generation {generation}, Best fitness: {max(fitnesses)}, Best cost: {best_cost}")

    return best_solution, best_cost


# Run the genetic algorithm
# final_population = genetic_algorithm(100, 100)  # 50 individuals, 100 generations

final_solution, final_cost = genetic_algorithm(100, 500)  # 50 individuals, 100 generations
print(f"Best Solution: {final_solution[0]}")
print(f"Optimal Cost: {final_cost}")
