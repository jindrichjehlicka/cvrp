import numpy as np
import random
import vrplib


# --- Genetic Algorithm Functions ---
def generate_population(pop_size, num_customers):
    population = []
    for _ in range(pop_size):
        individual = generate_route(num_customers)
        population.append(individual)
    return population


def generate_route(num_customers):
    route = list(range(1, num_customers + 1))  # Exclude depot
    random.shuffle(route)
    return route


def evaluate_fitness(route, dist_matrix, demands, capacity):
    total_distance = 0
    current_load = 0

    for i in range(len(route)):
        current_load += demands[route[i]]

        if i < len(route) - 1:
            total_distance += dist_matrix[route[i]][route[i + 1]]
        else:
            total_distance += dist_matrix[route[i]][0]  # Back to depot

        if current_load > capacity:
            return float('inf')  # Penalty for violating capacity constraint

    return total_distance


def crossover(parent1, parent2):
    cut_point1 = random.randint(0, len(parent1) - 2)
    cut_point2 = random.randint(cut_point1 + 1, len(parent1) - 1)

    # Create mappings for conflict resolution
    mapping1, mapping2 = {}, {}
    for i in range(cut_point1, cut_point2 + 1):
        mapping1[parent1[i]] = parent2[i]
        mapping2[parent2[i]] = parent1[i]

    # Create offspring
    def apply_mapping(route, mapping):
        for i in range(len(route)):
            if route[i] in mapping:
                route[i] = mapping[route[i]]
        return route

    offspring1 = parent1[:cut_point1] + parent2[cut_point1:cut_point2 + 1] + parent1[cut_point2 + 1:]
    offspring2 = parent2[:cut_point1] + parent1[cut_point1:cut_point2 + 1] + parent2[cut_point2 + 1:]

    offspring1 = apply_mapping(offspring1, mapping2)
    offspring2 = apply_mapping(offspring2, mapping1)

    return offspring1, offspring2


# --- Mutation (Swap Mutation) ---
def mutation(route):
    i, j = random.sample(range(len(route)), 2)
    route[i], route[j] = route[j], route[i]
    return route


# --- Selection (Tournament Selection) ---
def selection(population, fitness_scores, selection_size):
    selected_parents = []
    for _ in range(selection_size):
        tournament_participants = random.sample(range(len(population)), 3)  # Tournament size = 3
        best_index = np.argmin([fitness_scores[i] for i in tournament_participants])
        selected_parents.append(population[tournament_participants[best_index]])

    return selected_parents


def calculate_distance_matrix(coordinates):
    num_locations = len(coordinates)
    dist_matrix = np.zeros((num_locations, num_locations))
    for i in range(num_locations):
        for j in range(num_locations):
            dist_matrix[i][j] = np.linalg.norm(coordinates[i] - coordinates[j])
    return dist_matrix


instance = vrplib.read_instance("./Vrp-Set-XML100/instances/XML100_1111_01.vrp")
# Parameters from the instance
depot_loc = instance['node_coord'][0]  # Assuming the first coordinate is the depot
node_loc = instance['node_coord']
demand = instance['demand']
capacity = instance['capacity']
print("Depot location:", depot_loc)
print("Node locations:", node_loc)
print("Demand:", demand)
print("Capacity:", capacity)

# --- Main GA Loop ---
population = generate_population(pop_size=100, num_customers=len(node_loc) - 1)
dist_matrix = calculate_distance_matrix(node_loc)  # Calculate distances
best_route = None
best_fitness = float('inf')
for generation in range(250):  # Adjust number of generations
    fitness_scores = [evaluate_fitness(route, dist_matrix, demand, capacity)  # Fixed variable name
                      for route in population]
    selected_parents = selection(population, fitness_scores, selection_size=50)

    offspring = []
    for i in range(0, len(selected_parents), 2):
        parent1, parent2 = selected_parents[i], selected_parents[i + 1]
        child1, child2 = crossover(parent1, parent2)
        offspring.extend([child1, child2])

    # Apply mutation (with some probability)
    for i in range(len(offspring)):
        if random.random() < 0.3:  # Example mutation probability
            offspring[i] = mutation(offspring[i])
    for i in range(len(population)):
        if fitness_scores[i] < best_fitness:
            best_fitness = fitness_scores[i]
            best_route = population[i]
    population = offspring

print("Best route found:", best_route)
print("Optimal cost:", best_fitness)
